<?xml version="1.0" encoding="utf-8"?>
<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <FileVersion>
    <Major>1</Major>
    <Minor>0</Minor>
    <Patch>0</Patch>
  </FileVersion>
  <SDKVersion>
    <Major>1</Major>
    <Minor>1</Minor>
    <Patch>1</Patch>
  </SDKVersion>
  <Name>New Project</Name>
  <Services>
    <Service>
      <Name>NewProject</Name>
      <SIN>128</SIN>
      <Properties>
        <Property xsi:type="StringProperty">
          <Name>banner</Name>
          <PIN>201</PIN>
          <Value>service started</Value>
        </Property>
        <Property xsi:type="StringProperty">
          <Name>mb1_conf</Name>
          <Description>Read a modbus register and compares: 

Format: 
     &lt;address&gt; ; 
     &lt;base ( 0  or  1 )&gt; ;
     &lt;read/write = 1 &gt;;
     &lt;bits( 1 = 16, 2 = 32 )&gt; ; 
     &lt;direction(0-5)&gt; ; 
     &lt;threshold&gt; ;
</Description>
          <PIN>1</PIN>
          <Value>1;41100;1;0;1;0;70000;</Value>
        </Property>
        <Property xsi:type="StringProperty">
          <Name>mb2_conf</Name>
          <Description>Read a modbus register and compares: 

Format: 
     &lt;address&gt; ; 
     &lt;base ( 0  or  1 )&gt; ;
     &lt;read/write = 1 &gt;;
     &lt;bits( 1 = 16, 2 = 32 )&gt; ; 
     &lt;direction(0-5)&gt; ; 
     &lt;threshold&gt; ;
</Description>
          <PIN>2</PIN>
          <Value>1;41700;1;0;2;0;70000;</Value>
        </Property>
        <Property xsi:type="DataProperty">
          <Name>mb1_data</Name>
          <PIN>101</PIN>
          <Items>
            <unsignedByte>0</unsignedByte>
            <unsignedByte>0</unsignedByte>
            <unsignedByte>0</unsignedByte>
            <unsignedByte>0</unsignedByte>
          </Items>
        </Property>
        <Property xsi:type="DataProperty">
          <Name>mb2_data</Name>
          <PIN>102</PIN>
          <Items>
            <unsignedByte>0</unsignedByte>
            <unsignedByte>0</unsignedByte>
            <unsignedByte>0</unsignedByte>
            <unsignedByte>0</unsignedByte>
          </Items>
        </Property>
      </Properties>
      <SourceFiles>
        <SourceFile>
          <Name>main.lua</Name>
          <Source>--
-- Service: NewProject
-- Created: 2013-07-18
--

module(..., package.seeall)

--require("util.lua")

--
-- Version information (required)
--
_VERSION = "1.0.0"

--
-- Module Constants
--
local PERIODIC_ACTION_DELAY = 50
local COMMAND_TIMEOUT  = 5    -- Timeout of a modbus query/write function (in secs)
local COMMAND_INTERVAL = 1   -- Time between register queries (in secs)
local WORKER_THREAD_DELAY = 50

--
-- Module Globals
--

local workerThreadHandle = nil
local modbusThreadHandle = nil

local timer
local tPins                   -- Table that contains all PINs defined
local mb485Q                  -- Modbus queue in RS485
local modbushandle            -- Modbus handler

local control_table = { }     -- Control table of PIN values
local address_table = { }
local loop

----------------------------------
--  ModbusDemo function parameters
----------------------------------
local mod_address
local mod_register
local mod_base
local mod_read_write

-- For reading
local mod_bits
local mod_direction
local mod_threshold

--
-- Perform periodic action
--

-- -------------------------------------------------------------------------

local function extract_field(s_string)
    local s_field
    local first_p,second_p = string.find(s_string,";",1)
    if tonumber(first_p) ~= nil and tonumber(first_p) &gt; 1 then
        if tonumber(string.sub(s_string, 1, second_p-1) ) ~= nil then
            s_field = string.sub(s_string, 1, second_p-1)
            return s_field, string.sub(s_string, second_p + 1 , string.len(s_string))
        end
    end
    return false, s_string
end

local function fillParameters(pName, conf_params)
-- -------------------------------------------------------------------------
-- Fill variables from property configurationXX :
--  mod_address
--  mod_base
--  mod_read_write  = 0 for "read" 1 for "write"
--
-- if mod_read_write = 0 function will fill the following parameters:
--       mod_bits
--       mod_direction
--       mod_threshold
--       These 6 variables are going to be used to query a modbus address
--       Value read will be stored in modbusDataXX  ( 16 or 32 bits )
--   
-- if mod_read_write = 1 function will fill the following parameters:
--       mod_value
--       mod_times
--       These 5 variables are going to be used to write in a modbus address
--       Value to write will be taken from  modbusDataXX (16 bits only)
-- -------------------------------------------------------------------------
local val_counter = 1
local mb_addr = nil
local mb_reg = nil
local mb_base = nil
local mb_rw = nil
local mb_bit = nil
local mb_dir = nil
local mb_threshold = nil
local mb_value = nil
local mb_times = nil


 -- don't use "while extract_field(conf_params) == true do", doesn't mean the same
 -- due to configuration of function "extract_field()"
while extract_field(conf_params) ~= false do 
    if val_counter == 1 then
        mb_addr, conf_params = extract_field(conf_params)
        if tonumber(mb_addr) == 0 then
            trace("ERROR: invalid value for 'address' ", os.date())
            print("ERROR 1")
            return false
        end
        elseif val_counter == 2 then
            --print("param: ", conf_params)
            mb_reg, conf_params = extract_field(conf_params)
            if tonumber(mb_reg) == nil then
                trace("ERROR: wrong value for 'base' (must be 0 or 1) ", os.date())
                print("ERROR 2")
            return false
        end
        elseif val_counter == 3 then
            --print("param: ", conf_params)
            
            mb_base, conf_params = extract_field(conf_params)
            if tonumber(mb_base) ~= 0 and tonumber(mb_base) ~= 1 then
                trace("ERROR: wrong value for 'base' (must be 0 or 1) ", os.date())
                print("ERROR 3")
            return false
        end
        elseif val_counter == 4 then
            mb_rw, conf_params = extract_field(conf_params)
            if tonumber(mb_rw) ~= 0 and tonumber(mb_rw) ~= 1 then
                trace("ERROR: wrong value for 'read/write' (must be 0 or 1) ", os.date())
                print("ERROR 4")
            return false
        end
        elseif val_counter == 5 then
            if tonumber(mb_rw) == 0 then
                mb_bit, conf_params = extract_field(conf_params)
                if tonumber(mb_bit) ~= 1 and tonumber(mb_bit) ~= 2 then
                    trace("ERROR: wrong value for 'bits' (must be 1 or 2)", os.date())
                    print("ERROR 5A")
                return false
            end
            else
                mb_value, conf_params = extract_field(conf_params)
                if tonumber(mb_value) == nil or
                not (tonumber(mb_value) &gt;= 0 and tonumber(mb_value) &lt;= 65535) then
                    trace("ERROR: invalid value for 'value' (must be between 0 and 65535) ", os.date())
                    print("ERROR 5B")
                    return false
                end
            end
        elseif val_counter == 6 then
            if tonumber(mb_rw) == 0 then
                mb_dir, conf_params = extract_field(conf_params)
            if tonumber(mb_dir) == nil or
            not (tonumber(mb_dir) &gt;= 0 and tonumber(mb_dir) &lt;= 5) then
                trace("ERROR: invalid value for 'direction' (must be between 1 and 5) ", os.date())
                print("ERROR 6A")
                return false
            end
        else
            mb_times, conf_params = extract_field(conf_params)
            if tonumber(mb_times) == nil then
                trace("ERROR: invalid value for 'times' ", os.date())
                print("ERROR 6B")
                return false
            end
            break
        end
        elseif val_counter == 7 then
            if tonumber(mb_rw) == 0 then
                mb_threshold, conf_params = extract_field(conf_params)
                if tonumber(mb_threshold) == nil then
                    trace("ERROR: invalid value for 'threshold' ", os.date())
                    print("ERROR 7")
                    return false
                end
                break
            end
        end
    val_counter = val_counter + 1
    end
 
    if tonumber(mb_reg) == nil then
        trace("ERROR: missing parameter or delimitation for 'address' ", os.date())
        print ("ERROR register A")
        return false
    elseif string.len(mb_reg) ~= 5 then
        trace("ERROR: wrong value for 'address', expecting 5 digits ",mb_reg, " ", os.date())
        print ("ERROR register B")
        return false
    end
 
    if tonumber(mb_base) ~= 0 and tonumber(mb_base) ~= 1 then
        trace("ERROR: missing parameter or delimitation for 'base' ", os.date())
        print ("ERROR base")
        return false
    end
 
    if tonumber(mb_rw) ~= 0 and tonumber(mb_rw) ~= 1 then
        trace("ERROR: missing parameter or delimitation for 'read/write' ", os.date())
        print ("ERROR rw")
        return false
    end
 
    if tonumber(mb_rw) == 0 then
        if tonumber(mb_bit) ~= 1 and tonumber(mb_bit) ~= 2 then
            trace("ERROR: missing parameter or delimitation for 'bits' ", os.date())
            return false
        end
        if tonumber(mb_dir) == nil or
        not (tonumber(mb_dir) &gt;= 0 and tonumber(mb_dir) &lt;= 5) then
            trace("ERROR: missing parameter or delimitation for 'direction' ", os.date())
            return false
        end
        if tonumber(mb_threshold) == nil then
            trace("ERROR: missing parameter or delimitation for 'threshold' ", os.date())
            return false
        end
    else
        if tonumber(mb_value) == nil then
            trace("ERROR: missing parameter or delimitation for 'value' ", os.date())
            return false
        end
        if tonumber(mb_times) == nil then
            trace("ERROR: missing parameter or delimitation for 'times' ", os.date())
            return false
        end
    end
    
    return true, mb_addr, mb_reg, mb_base, mb_rw, mb_bit, mb_dir, mb_threshold, mb_value, mb_times

end

--[
function PrintSomething(_index)
    print( _index,"__ __", control_table[_index] ) -- index=PIN
end
--]]

local function baca_properti()
    local propField      -- to store properties definition
    local property_value -- to store property value
    tPins = svcmgr.getPropList(128)   -- Get properties list
    print(_NAME, ": getPropList ")
  
    -- Fill control_table with initial values
    table.foreach(tPins, function(k,v) table.insert(control_table,v,0) end )  --tekan kene lancar
    table.foreach(control_table, PrintSomething)
end

-- http://twolivesleft.com/Codea/Talk/discussion/2531/hex-or-binary-to-float/p1 --
local function hexToFloat(str)
    tab={["0"]="0000",["1"]="0001",["2"]="0010",["3"]="0011",
         ["4"]="0100",["5"]="0101",["6"]="0110",["7"]="0111",
         ["8"]="1000",["9"]="1001",["a"]="1010",["b"]="1011",
         ["c"]="1100",["d"]="1101",["e"]="1110",["f"]="1111",
         ["A"]="1010",["B"]="1011",["C"]="1100",["D"]="1101",["E"]="1110",["F"]="1111"}

    local str1=""
    local a,z
    for z=1,string.len(str) do
        a=string.sub(str,z,z)
        str1=str1..tab[a]
    end
    local pm=string.sub(str1,1,1)
    local exp=string.sub(str1,2,9)
    local c=tonumber(exp,2)-127
    local p=math.pow(2,c)
    local man="1"..string.sub(str1,10,32)
    local x=0
    for z=1,string.len(man) do
        if string.sub(man,z,z)=="1" then
            x=x+p
        end
        p=p/2
    end
    if pm=="1" then
        x= -x
    end    
    return(x)
end

local function readHoldingRegister(pin, idslave, register, base, bit)
    --print ("idslave: ", idslave, ", reg: ", register - base, ", modbit: ", bit, ", timeout: ", COMMAND_TIMEOUT * 1000)
    
    
    local result, error = modbushandle:readholdingregs(idslave, register - base, bit, COMMAND_TIMEOUT*1000)
    local q, event, success, error, count, data, raw = mb485Q:wait(-1)
    local extracted_value = 0
    
    if success then
        --print ("sukses !! terima data")
        local buf = sys.buffer.create(data)
        if tonumber(bit) == 1 then
            extracted_value = buf:getInt16()
            tracef("%s: Reading register #%d = 0x%04X , %s\n", _NAME, register, extracted_value, os.date() )
            
        else
            extracted_value = buf:getInt32()
            tracef("%s: Reading register #%d = 0x%08X , %s\n", _NAME, register, extracted_value , os.date() )
        end
        
        --print("ext_value: ", extracted_value)
        -- Save new content read in property modbusDataXX :
        local eror = svcmgr.setProp(128, pin + 100 , extracted_value )
        if error == nil then
            print("error: ", eror)
         end
        
        return true, extracted_value
    else
        trace("ERROR: ", error, ". Function readholdingregs(). Address (", register,") ",os.date())
        print("GAGAL terima modbus")
        return false, nil
    end   
    --]

--[[
        if conditionRequest(extracted_value, tonumber(mod_direction) , tonumber(mod_threshold), pin_pos) then
        
            trace(_NAME, ": *** Condition was triggered, sending message *** ", os.date() )
            sendMessage(1, { modbusAddress = tonumber(mod_address) , registerValue = data } ) 
            
        end
--]]
end


local function parsing_cmd_modbus(no , nama, params)
    --print("___ function parsing: ", nama, ": ", params)
    local tf, mb_addr, mb_reg, mb_base, mb_rw, mb_bit, mb_dir, mb_threshold, mb_value, mb_times = fillParameters(nama, params)
    --print ("alm: ", mb_addr,", reg: ", mb_reg, ", base: ",mb_base, ", rw: ",mb_rw)
    
    if tf then
        if tonumber(mb_rw) == 0 and string.sub(mb_reg, 1,1) == "4" then  -- rx:0, reg:4xxxx
            --print(" Read holding register(s):", no, ", addr: ", mb_addr, ", reg: ", tonumber(string.sub(mb_reg, 2))) --
            -- Take out the first address caracter
            local tf, hasil = readHoldingRegister(no, mb_addr, tonumber(string.sub(mb_reg, 2)), mb_base, mb_bit )  
            if tf then
                print ("Nilai[", mb_reg, "]: ", hasil)
            end
        elseif tonumber(mb_rw) == 1 and string.sub(mb_reg, 1,1) == "4" then   
            -- Write in a modbus holding register ---
            if tonumber(mb_times) &gt; 0 then
            --    WritingLoop("HOLDING_REG", nPin, tonumber(string.sub(mod_address, 2))) -- Take out the first address caracter                     
            end
            --
        else
            trace(_NAME, " : modbus function can not be executed with given address ", mb_reg , ".", os.date())
        end
    else
            
    end
    --]]
end

local function loop_properti()
    for i,nPin in pairs(tPins) do -- i=index, nPin=nilai PIN
        --print (i .. " &gt; " .. nPin)
        if nPin&lt;= 100 then
            propField = svcmgr.getPropDef(128,nPin)
            property_value = svcmgr.getProp(128, nPin)
            --print ("i:", i, ", nPin: ", nPin,", nama: ", propField.name, ": ", property_value)
            parsing_cmd_modbus(nPin, propField.name, property_value)
        end
    end
    collectgarbage('collect')
end


local function timerExpired()
  print(_NAME, ": timer masuk")
  loop_properti()
  print(_NAME, ": ______________________________________")
  timer:arm(PERIODIC_ACTION_DELAY)
end



local function OpenConnection()

--[[ Openning a Modbus connection  : sys.modbus.open (id, mode, baud, parity, plcAddr) 
     Parameters:
       id      The serial channel ID (RS232 or RS485)
       mode    The Modbus transmission mode to use (MODE_RTU or MODE_ASCII). 
               RTU connections use 8 data bits, while ASCII connections use 7 data bits.
       baud    The baud rate to use on the serial channel (optional;default is 9600)
       parity  The parity to use on the serial channel (optional; default is PARITY_EVEN). 
               PARITY_NONE is only supported with MODE_RTU on IDP terminals.
       plcAddr Boolean indicating whether PLC addressing should be used (optional; default is false)  
       
      .... see T202 document
  ]]
       
  local handle, error = sys.modbus.open(sys.modbus.RS485, sys.modbus.MODE_RTU, 9600, sys.modbus.PARITY_NONE)
  
   --
   if handle == nil then
       trace(_NAME, " modbus connection has failed. ", error,". ", os.date())
       print(_NAME, " MODBUS GAGAL. ")
   else
       modbushandle = handle
       print(_NAME, " MODBUS BERHASIL ++++. ")
   end
 
   return not (modbushandle == nil)
   --]]   
end

function Dec2Hex(nValue)
    if type(nValue) == "string" then
        nValue = tonumber(nValue);
    end 
    nHexVal = string.format("%X", nValue);  -- %X returns uppercase hex, %x gives lowercase letters
    sHexVal = nHexVal.."";
    return sHexVal;
end

local function workerThread()
    while true do
        print(_NAME, ": worker thread running")
        sched.delay(WORKER_THREAD_DELAY)
    end
end


-- Function called when service terminated
--
function onTermination()
    if workerThreadHandle then
        print(_NAME, ": terminating worker thread")
        workerThreadHandle:destroy()
        workerThreadHandle = nil
    end
    
    if modbusThreadHandle then
        print(_NAME, ": terminating modbus thread")
        modbusThreadHandle:destroy()
        modbusThreadHandle = nil
    end
end


local function modbus_req()
    timer = sys.timer.create()
    timer:arm(PERIODIC_ACTION_DELAY)
    local timerQ = sched.createEventQ(1, '_TIMER', timer)
    while true do
        local q, event, args = sched.waitQ(-1,  timerQ)
        if q == timerQ then
            timerExpired()
        end
    end
end

local function modbus_init()
    if OpenConnection() then
        print(_NAME, " MODBUS sukasuka connection open. ", os.date())   
        mb485Q = sched.createEventQ(1,'_MODBUS', modbushandle)
        return true
    else
        print (_NAME, "MODBUS GAGAL !!!!!!!")
    end
    return false
end

--
-- Run service (required)
--
function entry()
    print(_NAME, ": ", properties.banner)
  
    
    
    --print(hexToFloat("C58EBF11"))    -- -4567.89
    --print(hexToFloat("42f6e979"))    -- 123.456
    --print(hexToFloat("3f9e0610"))    -- 1.23456
    
    local mb = modbus_init()
    if mb then 
        print ("modbus TERBUKA")
        baca_properti()
        modbusThreadHandle = sched.spawn("modbus_thread", modbus_req)
        sched.delay(1)
    end
    
    
    print ("masuk thread worker")
    modbusThreadHandle = sched.spawn("worker_thread", workerThread)
    sched.delay(-1)
    
    print("masuk menu utama")
    
    
end

--
-- Initialize service (required)
--
function init()

end

</Source>
        </SourceFile>
        <SourceFile>
          <Name>util.lua</Name>
          <Source>
--[[
module(..., package.seeall)


function PrintSomething(_index)
    print( _index,"__ __", control_table[_index] ) -- index=PIN
end

--]]</Source>
        </SourceFile>
        <SourceFile>
          <Name>modbus.lua</Name>
          <Source>
--[[
module(..., package.seeall)

local function extract_field(s_string)
    local s_field
    local first_p,second_p = string.find(s_string,";",1)
    if tonumber(first_p) ~= nil and tonumber(first_p) &gt; 1 then
        if tonumber(string.sub(s_string, 1, second_p-1) ) ~= nil then
            s_field = string.sub(s_string, 1, second_p-1)
            return s_field, string.sub(s_string, second_p + 1 , string.len(s_string))
        end
    end
    return false, s_string
end

local function fillParameters(pName, conf_params)
-- -------------------------------------------------------------------------
-- Fill variables from property configurationXX :
--  mod_address
--  mod_base
--  mod_read_write  = 0 for "read" 1 for "write"
--
-- if mod_read_write = 0 function will fill the following parameters:
--       mod_bits
--       mod_direction
--       mod_threshold
--       These 6 variables are going to be used to query a modbus address
--       Value read will be stored in modbusDataXX  ( 16 or 32 bits )
--   
-- if mod_read_write = 1 function will fill the following parameters:
--       mod_value
--       mod_times
--       These 5 variables are going to be used to write in a modbus address
--       Value to write will be taken from  modbusDataXX (16 bits only)
-- -------------------------------------------------------------------------
local val_counter = 1
 
mod_address = nil
mod_register = nil
mod_base = nil
mod_read_write = nil

mod_bits = nil
mod_direction = nil
mod_threshold = nil

mod_value = nil
mod_times = nil


 -- don't use "while extract_field(conf_params) == true do", doesn't mean the same
 -- due to configuration of function "extract_field()"
while extract_field(conf_params) ~= false do 
    if val_counter == 1 then
        mod_address, conf_params = extract_field(conf_params)
        if tonumber(mod_address) == nil then
            trace("ERROR: invalid value for 'address' ", os.date())
        return false
    end
    elseif val_counter == 2 then
        mod_base, conf_params = extract_field(conf_params)
        if tonumber(mod_base) ~= 0 and tonumber(mod_base) ~= 1 then
            trace("ERROR: wrong value for 'base' (must be 0 or 1) ", os.date())
        return false
    end
    elseif val_counter == 3 then
        mod_read_write, conf_params = extract_field(conf_params)
        if tonumber(mod_read_write) ~= 0 and tonumber(mod_read_write) ~= 1 then
            trace("ERROR: wrong value for 'read/write' (must be 0 or 1) ", os.date())
        return false
    end
    elseif val_counter == 4 then
        if tonumber(mod_read_write) == 0 then
            mod_bits, conf_params = extract_field(conf_params)
            if tonumber(mod_bits) ~= 1 and tonumber(mod_bits) ~= 2 then
                trace("ERROR: wrong value for 'bits' (must be 1 or 2)", os.date())
            return false
        end
        else
            mod_value, conf_params = extract_field(conf_params)
            if tonumber(mod_value) == nil or
            not (tonumber(mod_value) &gt;= 0 and tonumber(mod_value) &lt;= 65535) then
                trace("ERROR: invalid value for 'value' (must be between 0 and 65535) ", os.date())
                return false
            end
        end
    elseif val_counter == 5 then
        if tonumber(mod_read_write) == 0 then
            mod_direction, conf_params = extract_field(conf_params)
        if tonumber(mod_direction) == nil or
        not (tonumber(mod_direction) &gt;= 0 and tonumber(mod_direction) &lt;= 5) then
            trace("ERROR: invalid value for 'direction' (must be between 1 and 5) ", os.date())
            return false
        end
    else
        mod_times, conf_params = extract_field(conf_params)
        if tonumber(mod_times) == nil then
            trace("ERROR: invalid value for 'times' ", os.date())
            return false
        end
        break
    end
    elseif val_counter == 6 then
        if tonumber(mod_read_write) == 0 then
            mod_threshold, conf_params = extract_field(conf_params)
            if tonumber(mod_threshold) == nil then
                trace("ERROR: invalid value for 'threshold' ", os.date())
                return false
            end
            break
        end
    end
    val_counter = val_counter + 1
 
 end
 
 if tonumber(mod_address) == nil then
  trace("ERROR: missing parameter or delimitation for 'address' ", os.date())
  return false
 elseif string.len(mod_address) ~= 5 then
  trace("ERROR: wrong value for 'address', expecting 5 digits ",mod_address, " ", os.date())
  return false
 end
 
 if tonumber(mod_base) ~= 0 and tonumber(mod_base) ~= 1 then
  trace("ERROR: missing parameter or delimitation for 'base' ", os.date())
  return false
 end
 
 if tonumber(mod_read_write) ~= 0 and tonumber(mod_read_write) ~= 1 then
  trace("ERROR: missing parameter or delimitation for 'read/write' ", os.date())
  return false
 end
 
 if tonumber(mod_read_write) == 0 then
  if tonumber(mod_bits) ~= 1 and tonumber(mod_bits) ~= 2 then
   trace("ERROR: missing parameter or delimitation for 'bits' ", os.date())
   return false
  end
  if tonumber(mod_direction) == nil or
  not (tonumber(mod_direction) &gt;= 0 and tonumber(mod_direction) &lt;= 5) then
   trace("ERROR: missing parameter or delimitation for 'direction' ", os.date())
   return false
  end
  if tonumber(mod_threshold) == nil then
   trace("ERROR: missing parameter or delimitation for 'threshold' ", os.date())
   return false
  end
 else
  if tonumber(mod_value) == nil then
   trace("ERROR: missing parameter or delimitation for 'value' ", os.date())
   return false
  end
  if tonumber(mod_times) == nil then
   trace("ERROR: missing parameter or delimitation for 'times' ", os.date())
   return false
  end
 end





 return true


end
--]]

 --[[
 -- For debugging purposes use :
 trace("address : ", mod_address)
 trace("base : ", mod_base)
 trace("read (0) or write(1) : ",mod_read_write)

 trace("16bits(1) or 32 bits(2) : ",mod_bits)
 trace("direction (R) (0: no comparison, 1: &gt;, 2: &lt;, 3: =, 4: &lt;&gt;, 5: any change ): ", mod_direction)
 trace("threshold (R) (to compare with register read) : ", mod_threshold)

 trace("value (W) to write : ",mod_value)
 trace("times (W) to write : ",mod_times)
--]]</Source>
        </SourceFile>
      </SourceFiles>
    </Service>
  </Services>
  <PropertyValues />
</Project>